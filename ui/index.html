<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Druppie">
    <meta name="theme-color" content="#0f172a">
    <title>Druppie</title>
    <link rel="icon" type="image/svg+xml" href="../druppie_logo.svg">
    <link rel="apple-touch-icon" href="../druppie_logo.png">
    <link rel="manifest" href="../manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap"
        rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <link rel="stylesheet" href="common.css">
    <script src="common.js"></script>
    <style>
        /* :root variables moved to common.css */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Hide Scrollbars */
        ::-webkit-scrollbar {
            display: none;
            width: 0;
            background: transparent;
        }

        html,
        body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background-color: var(--bg-deep);
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            display: grid;
            grid-template-columns: 380px 1fr;
            grid-template-rows: 1fr max-content;
            grid-template-areas:
                "sidebar main"
                "console console";
        }

        /* Layout */
        #sidebar {
            grid-area: sidebar;
            width: 100%;
            /* Fill grid column */
            background: var(--bg-card);
            border-right: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            z-index: 10;
            overflow: hidden;
            /* Force container constraint */
            min-height: 0;
            /* Allow shrinking in Grid */
        }

        #main-view {
            grid-area: main;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }

        /* Sidebar / Chat Area */
        .sidebar-header {
            padding: 0.5rem 0.5rem 0.5rem 0.5rem;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .sidebar-header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .sidebar-header i {
            color: var(--accent);
        }

        /* End Header */

        .sidebar-header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .sidebar-header i {
            color: var(--accent);
        }

        #notifications-wrapper {
            margin-left: auto;
            position: relative;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: background 0.2s;
        }

        #notifications-wrapper:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        #notification-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            background: #ef4444;
            color: white;
            font-size: 0.65rem;
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            border: 2px solid var(--bg-card);
        }

        #notification-list {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            width: 320px;
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow: hidden;
            display: none;
            backdrop-filter: blur(20px);
        }

        .notification-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--glass-border);
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-dim);
            background: rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .notification-item {
            padding: 1rem;
            border-bottom: 1px solid var(--glass-border);
            cursor: pointer;
            transition: background 0.2s;
        }

        .notification-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .notification-item:last-child {
            border-bottom: none;
        }

        .notification-plan {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
        }

        .notification-desc {
            font-size: 0.8rem;
            color: var(--text-main);
            line-height: 1.4;
        }

        .notification-meta {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tag-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .message {
            max-width: 90%;
            padding: 1rem;
            border-radius: 1rem;
            font-size: 0.95rem;
            line-height: 1.5;
            animation: fadeIn 0.3s ease;
            white-space: pre-wrap;
        }

        .param-box {
            margin-top: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem;
            border-radius: 0.5rem;
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
        }

        .param-list {
            margin: 0;
            padding: 0;
            list-style: none;
            font-size: 0.85rem;
        }

        .param-list li {
            margin-bottom: 0.5rem;
            display: block;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            padding-bottom: 0.5rem;
        }

        .param-list li:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }

        .param-list .key {
            color: var(--text-dim);
            font-weight: 600;
            font-size: 0.75rem;
            text-transform: uppercase;
            font-family: 'JetBrains Mono', monospace;
            display: inline;
            margin-right: 0.5rem;
        }

        .param-list .val {
            color: var(--text-main);
            white-space: pre-wrap;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            display: inline;
        }

        .array-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 0.5rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            border-radius: 0.25rem;
            border-left: 2px solid var(--accent);
            display: block;
        }

        .array-item:last-child {
            margin-bottom: 0;
        }

        .item-header {
            font-weight: 600;
            color: var(--accent);
            font-size: 0.75rem;
            margin-bottom: 0.25rem;
            opacity: 0.8;
            display: block;
        }

        .sub-row {
            display: block;
            margin-bottom: 0.25rem;
        }

        .sub-key {
            color: var(--text-dim);
            font-size: 0.75rem;
            display: inline;
            margin-right: 0.5rem;
        }

        .sub-val {
            color: var(--text-main);
            font-size: 0.8rem;
            display: inline;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            align-self: flex-end;
            background: var(--accent);
            color: var(--bg-deep);
            border-bottom-right-radius: 0.25rem;
        }

        .message.ai {
            align-self: flex-start;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-bottom-left-radius: 0.25rem;
        }

        .chat-input-wrapper {
            padding: 0rem;
            background: rgba(15, 23, 42, 0.5);
            backdrop-filter: blur(10px);
            border-top: 1px solid var(--glass-border);
        }

        .chat-input-container {
            position: relative;
            display: flex;
            gap: 0.5rem;
        }

        /* --- Injected Bell HTML --- */
        /* Note: Ideally this would be in the HTML body but we are patching */
        /* We rely on the header being rendered statically or we inject it dynamically below? */
        /* The header (sidebar-header) is in HTML body around line 96. */


        #prompt-input {
            flex: 1;
            background: var(--bg-deep);
            border: 1px solid var(--glass-border);
            border-radius: 0.75rem;
            padding: 0.75rem 1rem;
            color: white;
            font-family: inherit;
            outline: none;
            transition: border-color 0.2s;
        }

        #prompt-input:focus {
            border-color: var(--accent);
        }

        #send-btn {
            background: var(--accent);
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
        }

        #send-btn:hover {
            transform: scale(1.05);
        }

        /* Kanban Board */
        #kanban-container {
            flex: 1;
            padding: 0rem 2rem 0rem 2rem;
            overflow-x: auto;
            overflow-y: hidden;
            display: flex;
            gap: 2rem;
            background: radial-gradient(circle at top right, rgba(56, 189, 248, 0.05), transparent);
            transition: background 0.5s ease;
            min-height: 0;
        }

        #kanban-container.state-pending {
            background: radial-gradient(circle at top right, rgba(56, 189, 248, 0.15), rgba(56, 189, 248, 0.05));
        }

        #kanban-container.state-waiting_input {
            background: radial-gradient(circle at top right, rgba(251, 146, 60, 0.15), rgba(251, 146, 60, 0.05));
        }

        #kanban-container.state-running {
            background: radial-gradient(circle at top right, rgba(34, 197, 94, 0.15), rgba(34, 197, 94, 0.05));
        }

        #kanban-container.state-completed {
            background: radial-gradient(circle at top right, rgba(56, 189, 248, 0.05), transparent);
        }

        .kanban-col {
            flex: 1;
            min-width: 200px;
            display: flex;
            flex-direction: column;
            gap: 0;
            max-height: 100%;
        }

        .col-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem 0.25rem;
            flex-shrink: 0;
        }

        .col-cards {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding-top: 1rem;
        }

        .col-header h3 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-dim);
        }

        .task-count {
            background: var(--glass);
            padding: 0.125rem 0.5rem;
            border-radius: 1rem;
            font-size: 0.75rem;
        }

        .task-card {
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: 1rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, border-color 0.2s;
            cursor: default;
        }

        .task-card:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }

        .task-card.status-running {
            border-left: 3px solid var(--running);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.1);
        }

        .task-card.status-completed {
            opacity: 0.7;
            border-left: 3px solid var(--success);
        }

        .task-card.status-pending {
            border-left: 3px solid var(--pending);
        }

        .task-card.status-cancelled {
            opacity: 0.7;
            border-left: 3px solid #ef4444;
        }

        .task-card.status-skipped {
            opacity: 0.5;
            border-left: 3px solid #64748b;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .task-id {
            font-size: 0.75rem;
            font-family: 'JetBrains Mono';
            color: var(--text-dim);
        }

        .task-agent {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--accent);
        }

        .task-action {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .task-meta {
            font-size: 0.8rem;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 0.5rem;
            display: none;
        }

        /* Log Panel & Tabs */
        #bottom-panel {
            grid-area: console;
            position: relative;
            width: 100%;
            z-index: 50;
            max-height: 40vh;
            background: #0a0f1d;
            border-top: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            transition: max-height 0.3s ease, min-height 0.3s ease;
            min-height: 200px;
        }

        #bottom-panel.collapsed {
            max-height: 52px;
            min-height: 52px;
            overflow: hidden;
        }

        .tab-strip {
            padding: 0rem 0rem 0rem 0.5rem;
            background: rgba(255, 255, 255, 0.02);
            display: flex;
            gap: 2rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .tab-btn {
            padding: 1rem 0;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tab-btn.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .tab-content {
            flex: 1;
            padding: 1rem 1.5rem 3rem 1.5rem;
            /* Extra bottom padding for scroll */
            overflow-y: auto;
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #log-content {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: #cbd5e1;
            line-height: 1.6;
        }

        #step-log {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .step-log-item {
            padding: 0.5rem;
            background: var(--glass);
            border-radius: 0.5rem;
            border: 1px solid var(--glass-border);
            font-size: 0.85rem;
            /* removed white-space: pre-wrap to fix spacing issues */
        }

        .step-log-content {
            font-size: 0.75rem;
            color: var(--text-main);
            margin-top: 0.25rem;
            white-space: pre-wrap;
        }

        .step-log-header {
            display: flex;
            margin-bottom: 0.25rem;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .tag-agent {
            color: var(--accent);
        }

        .tag-action {
            color: var(--text-dim);
        }

        /* Interactive Cards */
        .interactive-controls {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
        }

        .btn-action {
            flex: 1;
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: white;
            font-size: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
            transition: all 0.2s;
        }

        .btn-action:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-action.primary {
            background: var(--accent);
            color: var(--bg-deep);
            border: none;
            font-weight: 600;
        }

        .btn-action.primary:hover {
            opacity: 0.9;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--glass-border);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Modal Overlay */
        #step-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        #step-modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: 1.5rem;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            position: relative;
            animation: modalSlideIn 0.3s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 0;
        }

        .modal-close-overlay {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            transition: all 0.2s;
            z-index: 1010;
        }

        .modal-close-overlay:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 1.5rem;
            margin-bottom: 0;
            border-bottom: 1px solid var(--glass-border);
            flex: none;
        }

        /* Old modal-close removed/ignored */

        #kanban-container {
            flex: 1;
            display: flex;
            gap: 1.5rem;
            padding: 1rem;
            /* Reduce padding to use more space */
            overflow-x: auto;
            align-items: flex-start;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            padding: 1.5rem;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 1.5rem;
            border-top: 1px solid var(--glass-border);
            background: var(--bg-card);
            flex: none;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .info-row {
            display: flex;
            gap: 0.5rem;
            font-size: 0.875rem;
        }

        .info-label {
            color: var(--text-dim);
            min-width: 100px;
        }

        .info-value {
            color: var(--text-main);
            flex: 1;
        }

        .modal-result {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 0.75rem;
            padding: 1rem;
            white-space: pre-wrap;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            max-height: 300px;
            overflow-y: auto;
        }

        .feedback-section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .feedback-input {
            background: var(--bg-deep);
            border: 1px solid var(--glass-border);
            border-radius: 0.75rem;
            padding: 0.75rem;
            color: white;
            font-family: inherit;
            resize: vertical;
            min-height: 80px;
            outline: none;
        }

        .feedback-input:focus {
            border-color: var(--accent);
        }

        .modal-actions {
            display: flex;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .modal-btn {
            flex: 1;
            padding: 0.75rem;
            border-radius: 0.75rem;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: white;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            transition: all 0.2s;
        }

        .modal-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        /* Mobile Responsive */
        /* Mobile Responsive - Reordered Layout */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                display: flex;
                height: 100vh;
                height: 100dvh;
                /* Dynamic Height for iOS Address Bar */
            }

            /* Unwrap Sidebar to reorder children independently */
            #sidebar {
                display: contents;
                /* This makes children direct children of body */
            }

            /* Specific styles for sidebar content when unwrapped */
            .sidebar-header {
                order: 1;
                /* 1. Header Top */
                width: 100%;
                background: var(--bg-card);
                border-bottom: 1px solid var(--glass-border);
                padding: 0.5rem 0.5rem 0.5rem 0.5rem;
                /* More space at bottom */
                height: auto;
                /* Allow growth */
                min-height: 60px;
                display: flex;
                align-items: center;
                flex-wrap: wrap;
                /* Allow wrapping if needed */
                position: sticky;
                /* Keep header visible */
                top: 0;
                z-index: 100;
                padding-top: env(safe-area-inset-top);
                /* Handle Notch */
                background: var(--bg-deep);
                /* Ensure opacity over content */
            }

            #main-view {
                order: 2;
                /* 2. Kanban Middle */
                height: 22vh;
                /* Reduced height to save space */
                flex: none;
                width: 100%;
                border-bottom: 1px solid var(--glass-border);
                background: var(--bg-deep);
            }

            #chat-messages {
                order: 3;
                /* 3. Chat Area */
                flex: 1;
                width: 100%;
                overflow-y: auto;
                background: var(--bg-card);
                padding: 1rem;
            }

            .chat-input-wrapper {
                order: 4;
                /* 4. Input Area */
                width: 100%;
                background: var(--bg-card);
                padding: 0.5rem 0.5rem 0 0.5rem;
                /* Minimal padding, bottom 0 */
                border-top: 1px solid var(--glass-border);
            }

            /* 5. System Console (Bottom) */
            #bottom-panel {
                order: 5;
                position: relative !important;
                width: 100%;
                bottom: auto;
                flex: none;
                flex-shrink: 0;
                /* Ensure it never shrinks */
                z-index: 200;
                /* Higher than input */
                max-height: 35vh;
                /* Compact console */
                overflow: hidden;
                /* Ensure content stays inside */
                padding-bottom: env(safe-area-inset-bottom);
                /* Handle Home Indicator */
            }

            /* Adjust Tab Strip for Mobile */
            .tab-strip {
                padding: 0 0 0 0.5rem;
                /* Push icon to right */
                align-items: center;
            }

            /* Kanban Horizontal Strip */
            #kanban-container {
                flex-direction: row;
                padding: 0.5rem;
                overflow-x: auto;
                overflow-y: visible;
                /* Allow headers to show */
                gap: 0.5rem;
                scroll-snap-type: x mandatory;
            }

            .kanban-col {
                min-width: 50vw;
                scroll-snap-align: center;
                height: 100%;
                background: rgba(255, 255, 255, 0.02);
                border-radius: 0.75rem;
                padding: 0.25rem 0.5rem;
            }

            .col-header {
                padding: 0.25rem 0;
                /* Minimal spacing for label */
            }

            .col-cards {
                overflow-y: auto;
                max-height: calc(25vh - 3rem);
                /* Match main-view height */
            }



            /* Compact Cards for Mobile */
            .task-card .task-meta {
                display: none;
            }

            .task-card {
                padding: 0.4rem;
                gap: 0rem;
                font-size: 0.75rem;
            }

            .task-card .task-header .task-agent {
                font-size: 0.75rem;
                font-weight: 600;
            }

            .task-card .task-header .task-id {
                font-size: 0.65rem;
            }

            .task-card .task-header {
                margin-bottom: 0.1rem;
            }

            .modal-content {
                width: 95%;
                /* Maximize width */
                max-height: 95vh;
                border-radius: 1rem 1rem 1rem 1rem;
                /* Bottom sheet style */
            }

            .modal-footer {
                padding: 1rem;
                /* Reduce footer padding */
            }

            .modal-actions {
                gap: 0.5rem;
                margin-top: 0;
            }

            .modal-btn {
                padding: 0.5rem;
                font-size: 0.8rem;
                white-space: nowrap;
                /* Prevent wrap */
            }
        }

        .modal-btn.primary {
            background: var(--accent);
            color: var(--bg-deep);
            border: none;
        }

        .modal-btn.primary:hover {
            opacity: 0.9;
        }

        .modal-btn.danger {
            background: #ef4444;
            color: white;
            border: none;
        }

        .modal-btn.danger:hover {
            opacity: 0.9;
        }

        .task-card {
            cursor: pointer;
        }

        /* --- Notification Styles --- */
        #notifications-wrapper {
            margin-left: auto;
            position: relative;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: background 0.2s;
        }

        #notifications-wrapper:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        #notification-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            background: #ef4444;
            color: white;
            font-size: 0.65rem;
            min-width: 16px;
            height: 16px;
            padding: 0 4px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            border: 2px solid var(--bg-card);
        }

        #notification-list {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 0.5rem;
            width: 320px;
            background: var(--bg-card);
            border: 1px solid var(--glass-border);
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.5), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            z-index: 100;
            overflow-y: auto;
            max-height: 400px;
            display: none;
            backdrop-filter: blur(20px);
        }

        .notification-header {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--glass-border);
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-dim);
            background: rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .notification-item {
            padding: 1rem;
            border-bottom: 1px solid var(--glass-border);
            cursor: pointer;
            transition: background 0.2s;
        }

        .notification-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .notification-item:last-child {
            border-bottom: none;
        }

        .notification-plan {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
        }

        .notification-desc {
            font-size: 0.8rem;
            color: var(--text-main);
            line-height: 1.4;
        }

        .notification-meta {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tag-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.1rem 0.4rem;
            border-radius: 0.25rem;
            font-family: 'JetBrains Mono';
            font-size: 0.65rem;
        }

        #stats-bar {
            width: 100%;
            padding: 0.5rem 2rem;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: flex-end;
            align-items: center;
            gap: 2rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            font-weight: 500;
            flex-shrink: 0;
            display: none;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .stat-value {
            color: var(--accent);
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
        }

        @media (max-width: 768px) {
            #stats-bar {
                padding: 0.5rem 0.5rem;
                gap: 0.5rem;
                justify-content: space-between;
                font-size: 0.7rem;
            }
        }
    </style>
</head>

<!-- Login Overlay -->
<div id="login-overlay" style="
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--bg-deep);
        z-index: 9999;
        display: none; 
        align-items: center;
        justify-content: center;
    ">
    <div style="
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 2rem; 
            border-radius: 1rem; 
            width: 100%; 
            max-width: 400px; 
            display: flex; 
            flex-direction: column; 
            gap: 1rem; 
            align-items: center;
        ">
        <img src="../druppie_logo.svg" style="width: 64px; height: 64px; border-radius: 0.75rem; margin-bottom: 1rem;">
        <h2 style="font-size: 1.5rem; font-weight: 600; color: white;">Druppie Chat</h2>
        <p style="color: var(--text-dim); font-size: 0.875rem;">Please sign in to continue</p>

        <form id="login-form" style="width: 100%; display: flex; flex-direction: column; gap: 1rem;">
            <input type="text" id="login-username" name="username" placeholder="Username" autocomplete="username"
                required
                style="width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); padding: 0.75rem; border-radius: 0.5rem; color: white; outline: none;">

            <input type="password" id="login-password" name="password" placeholder="Password"
                autocomplete="current-password" required
                style="width: 100%; background: rgba(0,0,0,0.2); border: 1px solid var(--glass-border); padding: 0.75rem; border-radius: 0.5rem; color: white; outline: none;">

            <div id="login-error" style="color: #ef4444; font-size: 0.875rem; display: none; text-align: center;">
                Invalid credentials</div>

            <button type="submit"
                style="width: 100%; background: var(--accent); color: var(--bg-deep); font-weight: 600; padding: 0.75rem; border-radius: 0.5rem; border: none; cursor: pointer;">Sign
                In</button>
        </form>
    </div>
</div>

<aside id="sidebar">
    <header class="sidebar-header">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 0.1rem;">
            <img src="../druppie_logo.svg" alt="Druppie" style="width: 32px; height: 32px;">
            <div id="app-version" style="font-size: 0.55rem; color: var(--text-dim); opacity: 0.7;">
                v...</div>
        </div>
        <div style="flex: 1; display: flex; flex-direction: column; gap: 0.5rem;">
            <div style="display: flex; align-items: center; justify-content: space-between;">
                <h1>Druppie Chat</h1>
                <div style="display: flex; align-items: center; gap: 0.5rem;">
                    <!-- Notification Bell -->
                    <div id="notifications-wrapper">
                        <i data-lucide="bell" size="20"></i>
                        <span id="notification-badge" style="display:none">0</span>
                        <div id="notification-list">
                            <div class="notification-header">Pending Approvals</div>
                            <div id="notification-items"></div>
                        </div>
                    </div>

                    <button onclick="createNewPlan()" title="New plan" style="
                        background: transparent;
                        border: 1px solid var(--glass-border);
                        border-radius: 0.5rem;
                        padding: 0.25rem;
                        color: var(--text-dim);
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        width: 28px;
                        height: 28px;
                        transition: all 0.2s;
                    " onmouseover="this.style.color='white'; this.style.borderColor='var(--accent)'"
                        onmouseout="this.style.color='var(--text-dim)'; this.style.borderColor='var(--glass-border)'">
                        <i data-lucide="plus" size="16"></i>
                    </button>
                </div>
            </div>
            <select id="plan-selector" style="
                    background: var(--bg-deep);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    font-family: 'JetBrains Mono', monospace;
                    outline: none;
                    cursor: pointer;
                    width: 100%;
                    max-width: 100%;
                ">
                <option value="">Maak een plan...</option>
            </select>
        </div>
    </header>


    <div id="chat-messages">
        <div class="message ai">
            Hallo! Ik ben Druppie, de AI-Orchestrator. Wat kan ik voor je doen ?
        </div>
    </div>

    <div class="chat-input-wrapper">
        <div class="chat-input-container">
            <input type="text" id="prompt-input" placeholder="Type je vraag of opdracht hier...">
            <button id="send-btn" style="
                    background: var(--accent);
                    border: none;
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.75rem;
                    color: white;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="send" size="16"></i>
            </button>
        </div>
        <div
            style="display: flex; gap: 0.25rem; padding: 0.5rem 0; flex-wrap: wrap; align-items: center; justify-content: space-between;">
            <input type="file" id="file-input" style="display: none;" onchange="handleFileUpload(this)">
            <button onclick="document.getElementById('file-input').click()" title="Attach File" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="file-plus" size="14"></i>
            </button>
            <button onclick="handleCommand('/resume')" title="Resume Execution (/resume)" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="play-circle" size="14"></i>
            </button>
            <button onclick="handleCommand('/stop')" title="Stop Execution (/stop)" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="stop-circle" size="14"></i>
            </button>
            <button onclick="handleCommand('/del')" title="Delete Plan (/del)" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="trash-2" size="14"></i>
            </button>

            <button onclick="openCodeEditor()" title="Plan Files" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                ">
                <i data-lucide="code" size="14"></i>
            </button>

            <a href="../index.html" title="Open Documentation Portal" style="
                    background: var(--glass-bg);
                    border: 1px solid var(--glass-border);
                    border-radius: 0.5rem;
                    padding: 0.25rem 0.5rem;
                    color: var(--text-dim);
                    font-size: 0.75rem;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    gap: 0.25rem;
                    text-decoration: none;
                ">
                <i data-lucide="book" size="14"></i>
            </a>

            <button id="logout-btn" onclick="handleLogout()" title="Logout" style="
                        background: transparent;
                        border: none;
                        padding: 0.25rem;
                        color: var(--text-dim);
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: all 0.2s;
                    " onmouseover="this.style.color='#ef4444'" onmouseout="this.style.color='var(--text-dim)'">
                <i data-lucide="log-out" size="18"></i>
            </button>
        </div>
    </div>
    </div>

</aside>

<main id="main-view">

    <div id="kanban-container">
        <div class="kanban-col" id="col-pending">
            <div class="col-header">
                <h3>Wachtend</h3>
                <span class="task-count">0</span>
            </div>
            <div class="col-cards"></div>
        </div>

        <div class="kanban-col" id="col-interaction">
            <div class="col-header">
                <h3>Interactie</h3>
                <span class="task-count">0</span>
            </div>
            <div class="col-cards"></div>
        </div>

        <div class="kanban-col" id="col-running">
            <div class="col-header">
                <h3>Bezig</h3>
                <span class="task-count">0</span>
            </div>
            <div class="col-cards"></div>
        </div>

        <div class="kanban-col" id="col-completed">
            <div class="col-header">
                <h3>Voltooid</h3>
                <span class="task-count">0</span>
            </div>
            <div class="col-cards"></div>
        </div>
    </div>

</main>

<div id="bottom-panel" class="collapsed">
    <div class="tab-strip">
        <div id="tab-btn-system" class="tab-btn active" onclick="switchTab('system')">
            <i data-lucide="terminal" size="14"></i>
            System Console
        </div>
        <div id="tab-btn-process" class="tab-btn" onclick="switchTab('process')">
            <i data-lucide="activity" size="14"></i>
            Planner - Agents
        </div>
        <div style="flex: 1;"></div>
        <button id="toggle-console-btn" onclick="toggleConsole()"
            style="background: none; border: none; color: var(--text-dim); cursor: pointer; padding: 0 1rem; display: flex; align-items: center;"
            title="Toggle Console">
            <i data-lucide="chevron-up" size="16"></i>
        </button>
    </div>

    <div id="system-tab" class="tab-content active">
        <div id="log-content">
            <div class="log-entry info">Verbinding actief. Wacht op taken...</div>
        </div>
    </div>

    <div id="process-tab" class="tab-content">
        <div id="stats-bar">
            <div class="stat-item">
                <i data-lucide="cpu" size="14"></i>
                <span>Tokens</span>
                <span>Prompt: <span id="stat-prompt" class="stat-value">0</span></span>
            </div>
            <div class="stat-item">
                <span>Completion: <span id="stat-completion" class="stat-value">0</span></span>
            </div>
            <div class="stat-item">
                <span>Internal: <span id="stat-planner" class="stat-value">0</span></span>
            </div>
            <div class="stat-item">
                <span>Total: <span id="stat-total" class="stat-value">0</span></span>
            </div>
        </div>
        <div id="step-log">
            <div class="message">Maak een plan...</div>
        </div>
    </div>
</div>


<!-- Step Detail Modal -->
<div id="step-modal">
    <button class="modal-close-overlay" onclick="closeStepModal()">
        <i data-lucide="x" size="24"></i>
    </button>
    <div class="modal-content">
        <div class="modal-header">
            <div>
                <h2 id="modal-title" style="font-size: 1.25rem; margin-bottom: 0.5rem;"></h2>
                <div id="modal-subtitle" style="font-size: 0.875rem; color: var(--text-dim);"></div>
            </div>
        </div>
        <div class="modal-body" id="modal-body"></div>
        <div class="modal-footer" id="modal-footer" style="display: none;"></div>
    </div>
</div>

<script>
    lucide.createIcons();

    // State management
    const state = {
        currentPlanId: null,
        lastLogIndex: 0,
        pollingInterval: null,
        stateInterval: null,
        isWaitingForInput: false,
        shownStepIds: new Set(),
        token: localStorage.getItem('druppie_token'),
        user: null,
        isDemo: false,
        lastUserPrompt: null
    };

    function openCodeEditor() {
        if (!state.currentPlanId) {
            return; // Silently return if no plan selected
        }
        window.location.href = `/code?plan_id=${state.currentPlanId}`;
    }

    // --- Auth Logic ---

    async function checkConfig() {
        try {
            const res = await fetch('/info');
            if (!res.ok) return false;
            const info = await res.json();

            // Allow access if provider is demo
            // The info endpoint returns { "auth_required": bool, "iam": { "provider": "..." } }
            // If auth_required is false, we bypass. 
            // We can also double check iam.provider if we want, but the server logic handles it.

            if (info.auth_required === false) return true;

            return false;
        } catch (e) {
            console.warn("Config check failed", e);
            return false;
        }
    }

    async function initAuth() {
        if (state.stateInterval) clearInterval(state.stateInterval);

        // First check server config to see if we can bypass auth
        const bypassAuth = await checkConfig();
        if (bypassAuth) {
            state.isDemo = true;
            document.getElementById('login-overlay').style.display = 'none';
            // Hide logout button in demo mode
            const logoutBtn = document.getElementById('logout-btn');
            if (logoutBtn) logoutBtn.style.display = 'none';
        } else {
            // Try recover user
            const storedUser = localStorage.getItem('druppie_user');
            if (storedUser) {
                try { state.user = JSON.parse(storedUser); } catch (e) { }
            }

            if (!state.token) {
                showLogin();
                return;
            }
            // Optimistic success, hide login
            document.getElementById('login-overlay').style.display = 'none';
        }

        // Start things
        fetchVersion();
        state.stateInterval = setInterval(updatePlanSelector, 5000);

        // Check for plan_id in URL parameter (e.g., from code editor)
        const urlParams = new URLSearchParams(window.location.search);
        const planIdParam = urlParams.get('plan_id');

        if (planIdParam) {
            await updatePlanSelector();
            setTimeout(() => {
                const selector = document.getElementById('plan-selector');
                if (selector && selector.value !== planIdParam) {
                    selector.value = planIdParam;
                    const event = new Event('change', { bubbles: true });
                    selector.dispatchEvent(event);
                }
            }, 100);
            // Clean up URL (remove parameter) keeping current path
            const newUrl = window.location.pathname;
            window.history.replaceState({}, '', newUrl);
        } else {
            updatePlanSelector();
        }
    }

    async function fetchVersion() {
        try {
            const res = await fetch('/v1/version');
            if (res.ok) {
                const data = await res.json();
                const el = document.getElementById('app-version');
                if (el) el.textContent = `v${data.version}`;
            }
        } catch (e) {
            console.warn("Failed to fetch version", e);
        }
    }

    function showLogin() {
        if (state.stateInterval) clearInterval(state.stateInterval);
        document.getElementById('login-overlay').style.display = 'flex';
    }

    async function handleLogout() {
        try {
            await fetch('/v1/iam/logout', {
                method: 'POST',
                headers: { 'Authorization': 'Bearer ' + state.token }
            });
        } catch (e) { console.warn("Logout cleanup error", e); }

        localStorage.removeItem('druppie_token');
        localStorage.removeItem('druppie_user');
        location.reload();
    }
    window.onAuthFailure = handleLogout;

    document.getElementById('login-form').onsubmit = async (e) => {
        e.preventDefault();
        const u = document.getElementById('login-username').value;
        const p = document.getElementById('login-password').value;
        try {
            const res = await fetch('/v1/iam/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ username: u, password: p })
            });

            if (!res.ok) throw new Error();
            const data = await res.json();

            localStorage.setItem('druppie_token', data.token);
            localStorage.setItem('druppie_user', JSON.stringify(data.user));
            state.token = data.token;
            state.user = data.user;

            location.reload();
        } catch (err) {
            document.getElementById('login-error').style.display = 'block';
        }
    };

    // Auth interceptor moved to common.js

    // --- End Auth Logic ---

    const elements = {
        prompt: document.getElementById('prompt-input'),
        send: document.getElementById('send-btn'),
        chat: document.getElementById('chat-messages'),
        systemLogs: document.getElementById('log-content'),
        stepLogs: document.getElementById('step-log'),
        planSelector: document.getElementById('plan-selector'),
        cols: {
            pending: document.getElementById('col-pending'),
            interaction: document.getElementById('col-interaction'),
            running: document.getElementById('col-running'),
            completed: document.getElementById('col-completed')
        }
    };

    // Plan selector change handler
    elements.planSelector.onchange = async function () {
        const selectedPlanId = this.value;
        if (!selectedPlanId || selectedPlanId === state.currentPlanId) return;

        state.lastLogIndex = 0;
        state.shownStepIds = new Set();
        elements.systemLogs.innerHTML = '';
        elements.stepLogs.innerHTML = '';
        elements.chat.innerHTML = '';
        if (state.currentPlanId)
            addChatMessage('ai', ` Wissel naar plan: ${selectedPlanId}`);
        state.currentPlanId = selectedPlanId;
        startMonitoring();
    };

    // Update plan selector with available plans
    async function updatePlanSelector() {
        // Token check removed to allow Demo Mode (which has no token) to fetch plans.
        // The fetch interceptor handles 401s if they occur.


        try {
            const resp = await fetch('/v1/plans');
            if (resp.status === 401) return; // Handled by interceptor
            if (resp.status === 500) {
                const selector = elements.planSelector;
                selector.innerHTML = '<option value="">Fout bij laden plannen (500)</option>';
                return;
            }
            if (!resp.ok) return;

            const plans = await resp.json();
            const selector = elements.planSelector;
            const currentVal = selector.value;

            // Save current options to check for diffs if needed, or just rebuild
            selector.innerHTML = '<option value="">Maak een plan...</option>';

            if (!plans || !Array.isArray(plans)) {
                return;
            }

            plans.sort((a, b) => {
                // Approximate sort by ID (timestamp based usually) descending
                if (a.plan_id > b.plan_id) return -1;
                if (a.plan_id < b.plan_id) return 1;
                return 0;
            });

            plans.forEach(p => {
                const opt = document.createElement('option');
                opt.value = p.plan_id;
                // Add status icon char maybe?
                let statusChar = '';
                if (p.status === 'stopped') statusChar = '';
                if (p.status === 'waiting_input') statusChar = '';
                if (p.status === 'running') statusChar = '';
                if (p.status === 'completed') statusChar = '';
                if (p.status === 'failed') statusChar = '';

                // Show Plan ID + first few words of intent
                const shortId = p.plan_id.replace('plan-', '');
                let label = shortId;
                if (p.intent && (p.intent.prompt || p.intent.initial_prompt)) {
                    let txt = p.intent.prompt || p.intent.initial_prompt;
                    if (txt.length > 30) txt = txt.substring(0, 30) + '...';
                    label = `${statusChar} ${txt} (${shortId})`;
                }
                opt.textContent = label;
                selector.appendChild(opt);
            });

            if (state.currentPlanId) {
                selector.value = state.currentPlanId;
            } else if (currentVal) {
                selector.value = currentVal;
            }
        } catch (e) {
            console.error('Plan selector update failed', e);
        }
    }

    // Update selector periodically
    // Update selector periodically - MOVED TO initAuth
    // setInterval(updatePlanSelector, 5000);
    // updatePlanSelector();

    function switchTab(name) {
        const panel = document.getElementById('bottom-panel');
        const btnId = name === 'system' ? 'tab-btn-system' : 'tab-btn-process';
        const clickedBtn = document.getElementById(btnId);

        // Robust check for active state
        const isAlreadyActive = clickedBtn.classList.contains('active');

        if (isAlreadyActive) {
            // If active, just toggle the panel visibility
            toggleConsole();
            return;
        }

        // If switching to a NEW tab:
        // 1. Deactivate all buttons
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        // 2. Hide all contents
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

        // 3. Activate specific button and content
        clickedBtn.classList.add('active');
        if (name === 'system') {
            document.getElementById('system-tab').classList.add('active');
        } else {
            document.getElementById('process-tab').classList.add('active');
        }

        // 4. Ensure panel is OPEN (remove collapsed) if it was closed
        if (panel.classList.contains('collapsed')) {
            toggleConsole();
        }
    }

    function toggleConsole() {
        const panel = document.getElementById('bottom-panel');
        const btn = document.getElementById('toggle-console-btn');

        panel.classList.toggle('collapsed');
        const isCollapsed = panel.classList.contains('collapsed');

        if (isCollapsed) {
            btn.innerHTML = '<i data-lucide="chevron-up" size="16"></i>';
        } else {
            btn.innerHTML = '<i data-lucide="chevron-down" size="16"></i>';
        }
        lucide.createIcons();
    }

    async function handleFileUpload(input) {
        if (!input.files || input.files.length === 0) return;
        const file = input.files[0];

        if (!state.currentPlanId) {
            addChatMessage('ai', ' Geen actief plan. Selecteer of maak eerst een plan voordat je bestanden uploadt.');
            input.value = ''; // Reset input
            return;
        }

        const formData = new FormData();
        formData.append('file', file);

        const msg = addChatMessage('ai', ` Uploaden van bestand: ${file.name}...`);

        try {
            const resp = await fetch(`/v1/plans/${state.currentPlanId}/files`, {
                method: 'POST',
                body: formData
            });

            if (resp.ok) {
                msg.textContent = ` Bestand geupload: ${file.name}`;
                // Optionally notify planner if waiting for input?
                // For now, just logging it to chat is fine, the planner will see it in context next turn.
            } else {
                const err = await resp.text();
                msg.textContent = ` Fout bij uploaden: ${err}`;
            }
        } catch (e) {
            msg.textContent = ` Netwerk fout: ${e.message}`;
        }
        input.value = ''; // Reset input to allow re-uploading same file
    }

    async function sendMessage() {
        const prompt = elements.prompt.value.trim();
        if (!prompt) return;
        state.lastUserPrompt = prompt;

        addChatMessage('user', prompt);
        elements.prompt.value = '';

        // Handle commands
        if (prompt.startsWith('/')) {
            handleCommand(prompt);
            return;
        }

        if (state.isWaitingForInput && state.currentPlanId) {
            sendTaskInput(state.currentPlanId, prompt);
            return;
        }

        // Optimistic UI: Show immediate feedback
        const thinkingMsg = addChatMessage('ai', ' Analyseren van je verzoek...');

        try {
            const resp = await fetch('/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt,
                    plan_id: state.currentPlanId
                })
            });
            const data = await resp.json();

            // Remove thinking message
            thinkingMsg.remove();

            if (data.plan) {
                // Reset state if we are switching to a new/different plan
                if (state.currentPlanId !== data.plan.plan_id) {
                    state.shownStepIds = new Set();
                    state.lastLogIndex = 0;
                    elements.systemLogs.innerHTML = '';
                    elements.stepLogs.innerHTML = '';
                    // Clear chat history so we can rebuild it from the new plan correctly
                    // Note: This temporarily removes the optimistic user bubble, but strict consistency restores it
                    elements.chat.innerHTML = '';
                    // Restore the user prompt immediately
                    addChatMessage('user', prompt);

                    // Prevent duplication in updatePlan by fast-forwarding the shown ID
                    if (data.plan.steps && data.plan.steps.length > 0) {
                        const lastStep = data.plan.steps[data.plan.steps.length - 1];
                        if (lastStep.action === 'user_query') {
                            state.shownStepIds = state.shownStepIds || new Set();
                            state.shownStepIds.add(lastStep.step_id);
                        }
                    }
                }
                state.currentPlanId = data.plan.plan_id;
                state.lastShownStepId = state.lastShownStepId || 0;

                // addChatMessage('ai', ` Plan gemaakt: ${state.currentPlanId}\nOrchestration gestart...`);

                // Update plan selector to show new plan
                updatePlanSelector();

                // Start monitoring immediately to show the pending plan
                startMonitoring();
            } else if (data.intent) {
                if (data.intent.answer) {
                    addChatMessage('ai', data.intent.answer);
                } else {
                    addChatMessage('ai', `Analyse: ${data.intent.action}.`);
                }
            }
        } catch (err) {
            thinkingMsg.remove();
            addChatMessage('ai', `Error: ${err.message}`);
        }
    }

    function showOptimisticTask(planId, prompt) {
        // Create a temporary pending card
        const card = document.createElement('div');
        card.className = 'task-card status-pending';
        card.id = `temp-card-${planId}`;

        card.innerHTML = `
                <div class="task-header">
                    <span class="task-agent">orchestrator</span>
                    <span class="task-id">${planId}</span>
                </div>
                <div class="task-action">${prompt.substring(0, 50)}${prompt.length > 50 ? '...' : ''}</div>
                <div class="task-meta">
                     <i data-lucide="loader-2" size="12" class="lucide-spin"></i>
                     initialiseren
                </div>
            `;

        elements.cols.pending.appendChild(card);
        elements.cols.pending.querySelector('.task-count').textContent = '1';
        lucide.createIcons();

        // Add spinning animation
        const style = document.createElement('style');
        style.textContent = `
                .lucide-spin {
                    animation: spin 1s linear infinite;
                }
                @keyframes spin {
                    from { transform: rotate(0deg); }
                    to { transform: rotate(360deg); }
                }
            `;
        document.head.appendChild(style);
    }

    async function handleCommand(cmd) {
        const parts = cmd.split(' ');
        const command = parts[0].toLowerCase();

        switch (command) {
            case '/list':
                try {
                    const resp = await fetch('/v1/plans');
                    const plans = await resp.json();
                    if (plans && plans.length > 0) {
                        const list = plans.map(p => ` ${p.plan_id} - ${p.status}`).join('\n');
                        addChatMessage('ai', ` Actief Plan:\n${list}`);
                    } else {
                        addChatMessage('ai', ' Geen actief plan.');
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout bij het weergeven van de actieve plannen: ${e.message}`);
                }
                break;

            case '/stop':
                if (state.currentPlanId) {
                    try {
                        const resp = await fetch(`/v1/plans/${state.currentPlanId}/stop`, { method: 'POST' });
                        if (resp.ok) {
                            addChatMessage('ai', ' Stop signaal verstuurd.');
                        } else {
                            addChatMessage('ai', ` Fout bij het stoppen van het plan: ${await resp.text()}`);
                        }
                    } catch (e) {
                        addChatMessage('ai', ` Fout bij het stoppen van het plan: ${e.message}`);
                    }
                } else {
                    addChatMessage('ai', ' Geen actief plan om te stoppen.');
                }
                break;

            case '/switch':
                if (parts[1]) {
                    state.currentPlanId = parts[1];
                    state.lastLogIndex = 0;
                    state.shownStepIds = new Set();
                    elements.systemLogs.innerHTML = '';
                    elements.stepLogs.innerHTML = '';
                    addChatMessage('ai', ` Actief plan veranderd naar: ${parts[1]}`);
                    startMonitoring();
                } else {
                    addChatMessage('ai', ' Gebruik: /switch <plan-id>');
                }
                break;

            case '/del':
            case '/delete':
                const delPlanId = parts[1] || state.currentPlanId;
                if (!delPlanId) {
                    addChatMessage('ai', ' Geen plan om te verwijderen. Gebruik: /del <plan-id>');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${delPlanId}`, { method: 'DELETE' });
                    if (resp.ok) {
                        addChatMessage('ai', ` Plan verwijderd: ${delPlanId}`);
                        if (state.currentPlanId === delPlanId) {
                            state.currentPlanId = null;
                            elements.systemLogs.innerHTML = '';
                            elements.stepLogs.innerHTML = '';

                            // Clear Kanban board
                            Object.values(elements.cols).forEach(col => {
                                const cardsContainer = col.querySelector('.col-cards');
                                if (cardsContainer) cardsContainer.innerHTML = '';
                                col.querySelector('.task-count').textContent = '0';
                            });

                            // Reset Kanban background
                            document.getElementById('kanban-container').className = '';

                            if (state.pollingInterval) clearInterval(state.pollingInterval);
                        }
                        updatePlanSelector();
                    } else {
                        addChatMessage('ai', ` Fout bij het verwijderen van het plan: ${await resp.text()}`);
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout bij het verwijderen van het plan: ${e.message}`);
                }
                break;

            case '/resume':
                const resumePlanId = parts[1] || state.currentPlanId;
                if (!resumePlanId) {
                    addChatMessage('ai', ' Geen plan om te hervatten. Gebruik: /resume <plan-id>');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${resumePlanId}/resume`, { method: 'POST' });
                    if (resp.ok) {
                        addChatMessage('ai', ` Plan hervat: ${resumePlanId}`);
                        updatePlanSelector();
                    } else {
                        addChatMessage('ai', ` Fout bij het hervatten van het plan: ${await resp.text()}`);
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout bij het hervatten van het plan: ${e.message}`);
                }
                break;

            case '/add_group':
                if (!state.currentPlanId) {
                    addChatMessage('ai', ' Geen actief plan.');
                    break;
                }
                const addGroup = parts[1];
                if (!addGroup) {
                    addChatMessage('ai', ' Gebruik: /add_group <group_name>');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${state.currentPlanId}/groups/${addGroup}`, { method: 'POST' });
                    if (resp.ok) {
                        addChatMessage('ai', ` Groep '${addGroup}' toegevoegd aan plan.`);
                    } else {
                        addChatMessage('ai', ` Fout bij toevoegen groep: ${await resp.text()}`);
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout: ${e.message}`);
                }
                break;

            case '/remove_group':
                if (!state.currentPlanId) {
                    addChatMessage('ai', ' Geen actief plan.');
                    break;
                }
                const rmGroup = parts[1];
                if (!rmGroup) {
                    addChatMessage('ai', ' Gebruik: /remove_group <group_name>');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${state.currentPlanId}/groups/${rmGroup}`, { method: 'DELETE' });
                    if (resp.ok) {
                        addChatMessage('ai', ` Groep '${rmGroup}' verwijderd van plan.`);
                    } else {
                        addChatMessage('ai', ` Fout bij verwijderen groep: ${await resp.text()}`);
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout: ${e.message}`);
                }
                break;

            case '/list_groups':
                if (!state.currentPlanId) {
                    addChatMessage('ai', ' Geen actief plan.');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${state.currentPlanId}/groups`);
                    if (resp.ok) {
                        const groups = await resp.json();
                        if (groups && groups.length > 0) {
                            addChatMessage('ai', ` Toegestane groepen:\n${groups.map(g => ` ${g}`).join('\n')}`);
                        } else {
                            addChatMessage('ai', ' Dit plan heeft geen specifieke toegangsgroepen ingesteld (alleen eigenaar).');
                        }
                    } else {
                        addChatMessage('ai', ` Fout bij ophalen groepen: ${await resp.text()}`);
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout: ${e.message}`);
                }
                break;

            case '/usage':
                if (!state.currentPlanId) {
                    addChatMessage('ai', ' Geen actief plan.');
                    break;
                }
                try {
                    const resp = await fetch(`/v1/plans/${state.currentPlanId}`);
                    if (!resp.ok) throw new Error('Failed to fetch plan');
                    const plan = await resp.json();

                    if (plan.total_usage) {
                        const u = plan.total_usage;
                        const costLine = plan.total_cost ? `\n Cost: ${plan.total_cost.toFixed(4)}` : ''; const msg = ` Token Usage:\n Prompt: ${u.prompt_tokens.toLocaleString()}\n Completion: ${u.completion_tokens.toLocaleString()}\n Total: ${u.total_tokens.toLocaleString()}${costLine}`;
                        addChatMessage('ai', msg);
                    } else {
                        addChatMessage('ai', ' No token usage data available for this plan.');
                    }
                } catch (e) {
                    addChatMessage('ai', ` Fout: ${e.message}`);
                }
                break;

            default:
                addChatMessage('ai', ` Onbekend commando: ${command}\n\nBeschikbare commando's:\n /list - Toon alle plannen\n /usage - Toon token usage\n /stop - Stop huidige plan\n /switch <plan-id> - Verander naar een ander plan\n /del <plan-id> - Verwijder een plan\n /resume <plan-id> - Hervat een gestopt plan\n /add_group <group> - Voeg toegangsgroep toe\n /remove_group <group> - Verwijder toegangsgroep\n /list_groups - Toon toegangsgroepen`);
        }
    }

    async function sendTaskInput(planId, text) {
        try {
            const resp = await fetch(`/v1/tasks/${planId}/message`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ input: text })
            });
            if (resp.ok) {
                state.isWaitingForInput = false;
                addChatMessage('user', `Input verstuurd: ${text.length > 50 ? text.substring(0, 50) + '...' : text}`);
            } else {
                const err = await resp.text();
                addChatMessage('ai', `Failed: ${err}`);
            }
        } catch (e) {
            addChatMessage('ai', `Connection error: ${e.message}`);
        }
    }

    function addChatMessage(role, text, isHtml = false) {
        const div = document.createElement('div');
        div.className = `message ${role}`;
        if (isHtml) {
            div.innerHTML = text;
        } else {
            div.textContent = text;
        }
        elements.chat.appendChild(div);
        div.scrollIntoView({ behavior: 'smooth' });
        return div; // Return element so it can be removed if needed
    }

    function startMonitoring() {
        if (state.pollingInterval) clearInterval(state.pollingInterval);
        state.currentPollingRate = 2000;
        updatePlan();
        updateLogs();
        setupPolling(state.currentPollingRate);
    }

    function setupPolling(rate) {
        if (state.pollingInterval) clearInterval(state.pollingInterval);
        state.currentPollingRate = rate;
        state.pollingInterval = setInterval(() => {
            updatePlan();
            updateLogs();
        }, rate);
    }

    async function updatePlan() {
        if (!state.currentPlanId || (!state.token && !state.isDemo)) return;
        try {
            const resp = await fetch(`/v1/plans/${state.currentPlanId}`);
            if (resp.status === 404) {
                // Plan deleted or invalid
                addChatMessage('ai', ` Plan ${state.currentPlanId} niet gevonden (404). Monitor gestopt.`);
                state.currentPlanId = null;
                if (state.pollingInterval) clearInterval(state.pollingInterval);

                // Clear UI
                elements.systemLogs.innerHTML = '';
                elements.stepLogs.innerHTML = '';

                // Refresh list to remove the invalid plan
                updatePlanSelector();
                return;
            }
            if (!resp.ok) return;
            const plan = await resp.json();

            // Ensure steps exist
            const steps = plan.steps || [];

            // Generic Chat Result Logic using Set
            state.shownStepIds = state.shownStepIds || new Set();

            // Process steps in order they appear in the plan
            steps.forEach(s => {
                if (s.status === 'completed' && !state.shownStepIds.has(s.step_id)) {
                    let msg = null;
                    let role = 'ai';

                    if (s.agent_id === 'user' || s.action.startsWith('review_')) {
                        role = 'user';
                    }

                    if (s.action === 'user_query' && s.result) {
                        role = 'user';
                        msg = s.result;
                        // Dedup Logic: If matches recently sent prompt, skip rendering
                        if (state.lastUserPrompt && msg === state.lastUserPrompt) {
                            state.shownStepIds.add(s.step_id);
                            state.lastUserPrompt = null; // Clear matches
                            msg = null; // Don't render
                        }
                    } else if ((s.action === 'general_chat' || s.agent_id === 'router') && s.result) {
                        msg = s.result;
                    } else {
                        // Generic Step Display
                        let label = s.action.replace(/_/g, ' ');
                        label = label.charAt(0).toUpperCase() + label.slice(1);

                        let details = '';

                        if (s.result && s.result.startsWith('RESULT_')) {
                            const raw = s.result;
                            const file = raw.split('=')[1] || raw;
                            const type = raw.includes('VIDEO') ? ' Video' : raw.includes('IMAGE') ? ' Image' : ' Result';
                            details = `<br><strong>${type}:</strong> ${file}`;
                        } else {
                            // Params Display
                            if (s.params && Object.keys(s.params).length > 0) {
                                const entries = Object.entries(s.params).filter(([k, v]) => v !== null && v !== undefined);
                                if (entries.length > 0) {
                                    let listHtml = '<ul class="param-list">';
                                    entries.forEach(([k, v]) => {
                                        let valStr = '';
                                        if (Array.isArray(v) && v.length > 0 && typeof v[0] === 'object') {
                                            // Format Array of Objects (like av_script)
                                            valStr = v.map((item, idx) => {
                                                let title = `Item ${idx + 1}`;
                                                if (item.scene_id) title = `Scene ${item.scene_id}`;

                                                let fields = Object.entries(item).map(([ik, iv]) => {
                                                    // Recursive simple stringify for sub-fields if needed
                                                    let displayVal = (typeof iv === 'object') ? JSON.stringify(iv) : String(iv);
                                                    return `<div class="sub-row"><span class="key">${ik}:</span> <span class="sub-val">${displayVal}</span></div>`;
                                                }).join('');

                                                return `<div class="array-item"><div class="item-header">${title}</div>${fields}</div>`;
                                            }).join('');
                                            // For array items, we use a div for val to allow block display of items
                                            listHtml += `<li><span class="key">${k}:</span> <div class="val" style="display:block">${valStr}</div></li>`;
                                        } else if (typeof v === 'object') {
                                            valStr = JSON.stringify(v, null, 2);
                                            listHtml += `<li><span class="key">${k}:</span> <span class="val">${valStr}</span></li>`;
                                        } else {
                                            valStr = String(v);
                                            listHtml += `<li><span class="key">${k}:</span> <span class="val">${valStr}</span></li>`;
                                        }
                                    });
                                    listHtml += '</ul>';

                                    details += `<div class="param-box">${listHtml}</div>`;
                                }
                            }

                            // Result Display (if not Approved/Completed redundancy)
                            if (s.result && s.result !== 'Approved' && s.result !== 'Approved by user' && s.result !== 'completed') {
                                details += `<br><span class="text-dim">Result: ${s.result}</span>`;
                            }
                        }

                        msg = ` <strong>${label}</strong> completed.${details}`;
                    }

                    if (msg) {
                        addChatMessage(role, msg, true);
                    }

                    state.shownStepIds.add(s.step_id);
                }
            });

            renderPlan(plan);
            renderStepList(plan);

            if (plan.status === 'waiting_input' && !state.isWaitingForInput) {
                state.isWaitingForInput = true;
                const waitingStep = plan.steps.find(s => s.status === 'waiting_input' || (s.status === 'running' && plan.status === 'waiting_input'));

                let label = 'Task';
                let content = 'Task is waiting for your input. Use buttons on Kanban or type feedback.';

                if (waitingStep) {
                    label = waitingStep.action.replace(/_/g, ' ');
                    label = label.charAt(0).toUpperCase() + label.slice(1);

                    if (waitingStep.result) {
                        content = waitingStep.result;
                    } else if (waitingStep.params) {
                        if (waitingStep.params.justification) {
                            content = "Justification: " + waitingStep.params.justification;
                        } else if (waitingStep.params.reason) {
                            content = "Reason: " + waitingStep.params.reason;
                        }
                    }
                }

                // Format content (lists to param-list, text to divs)
                const formatContentToHtml = (text) => {
                    if (!text) return '';
                    const lines = text.split('\n');
                    let html = '';
                    let inList = false;
                    let listHtml = '';

                    lines.forEach(line => {
                        const trimmed = line.trim();
                        if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
                            if (!inList) {
                                inList = true;
                                listHtml = '<ul class="param-list">';
                            }
                            const content = trimmed.substring(2);
                            let liContent = '';
                            if (content.includes(': ')) {
                                const [k, ...rest] = content.split(': ');
                                const v = rest.join(': ');
                                liContent = `<span class="key">${k}:</span> <span class="val">${v}</span>`;
                            } else {
                                liContent = `<span class="val">${content}</span>`;
                            }
                            listHtml += `<li>${liContent}</li>`;
                        } else {
                            if (inList) {
                                inList = false;
                                listHtml += '</ul>';
                                html += listHtml;
                            }
                            if (trimmed.length > 0) html += `<div>${line}</div>`;
                        }
                    });

                    if (inList) {
                        html += listHtml + '</ul>';
                    }
                    return html || text;
                };

                const msg = ` <strong>${label}</strong> waiting for your input.<br><div class="param-box">${formatContentToHtml(content)}</div>`;
                addChatMessage('ai', msg, true);
            } else if (plan.status !== 'waiting_input') {
                state.isWaitingForInput = false;
            }

            // Dynamic Polling Rate Adjustment
            // If plan is in a terminal or paused state, reduce polling frequency to save resources
            let desiredRate = 2000;
            if (plan.status === 'stopped' || plan.status === 'completed' || plan.status === 'failed') {
                desiredRate = 10000;
            }

            if (state.currentPollingRate !== desiredRate) {
                setupPolling(desiredRate);
            }
        } catch (e) { }
    }

    async function updateLogs() {
        if (!state.currentPlanId || (!state.token && !state.isDemo)) return;
        if (!state.currentPlanId) return;
        if (!state.currentPlanId) return;
        try {
            const resp = await fetch(`/v1/logs/${state.currentPlanId}`);
            if (!resp.ok) return;
            const text = await resp.text();
            let lines = text.split('\n');

            // Remove trailing empty line from split
            if (lines.length > 0 && lines[lines.length - 1] === '') {
                lines.pop();
            }

            const newLines = lines.slice(state.lastLogIndex);
            if (newLines.length > 0) {
                newLines.forEach(line => {
                    if (!line.trim()) return;
                    const logDiv = document.createElement('div');
                    logDiv.className = 'log-entry';
                    if (line.includes('[Workflow] Completed')) logDiv.classList.add('success');
                    else if (line.includes('')) logDiv.classList.add('warn');
                    logDiv.textContent = line;
                    elements.systemLogs.appendChild(logDiv);
                });
                elements.systemLogs.scrollTop = elements.systemLogs.scrollHeight;
                state.lastLogIndex = lines.length;
            }
        } catch (e) { }
    }

    let lastAutoScrollSignature = '';
    function renderPlan(plan) {
        // Update stats bar
        const statsBar = document.getElementById('stats-bar');
        if (plan.total_usage && plan.total_usage.total_tokens > 0) {
            statsBar.style.display = 'flex';
            if (plan.planning_usage && plan.planning_usage.total_tokens > 0) {
                document.getElementById('stat-prompt').textContent = (plan.total_usage.prompt_tokens - plan.planning_usage.prompt_tokens).toLocaleString();
                document.getElementById('stat-completion').textContent = (plan.total_usage.completion_tokens - plan.planning_usage.completion_tokens).toLocaleString();
                document.getElementById('stat-planner').textContent = (plan.planning_usage.total_tokens).toLocaleString();
            } else {
                document.getElementById('stat-prompt').textContent = plan.total_usage.prompt_tokens.toLocaleString();
                document.getElementById('stat-completion').textContent = plan.total_usage.completion_tokens.toLocaleString();
                document.getElementById('stat-planner').textContent = "0";
            }
            const totalText = plan.total_usage.total_tokens.toLocaleString();
            const costText = plan.total_cost ? ` (${plan.total_cost.toFixed(4)})` : '';
            document.getElementById('stat-total').textContent = totalText + costText;
        } else {
            statsBar.style.display = 'none';
        }



        plan.steps = plan.steps || [];
        // Update Kanban background based on plan state
        const kanbanContainer = document.getElementById('kanban-container');
        kanbanContainer.className = `state-${plan.status}`;

        Object.values(elements.cols).forEach(col => {
            const cardsContainer = col.querySelector('.col-cards');
            if (cardsContainer) {
                cardsContainer.innerHTML = '';
            }
        });

        const counts = { pending: 0, running: 0, completed: 0 };

        // If plan has no steps yet, show a placeholder
        if (plan.steps.length === 0) {
            if (plan.status === 'pending' || plan.status === 'running') {
                const isRunning = plan.status === 'running';
                const card = document.createElement('div');
                card.className = `task-card status-${plan.status}`;
                card.dataset.stepId = 0; // Add data-step-id for placeholder
                card.onclick = () => openStepModal({
                    step_id: 0,
                    agent_id: 'orchestrator',
                    action: isRunning ? 'Creating plan...' : 'Initializing plan...',
                    status: plan.status,
                    result: plan.intent.prompt || plan.intent.initial_prompt
                }, plan);

                card.innerHTML = `
                        <div class="task-header">
                            <span class="task-agent">orchestrator</span>
                            <span class="task-id">${plan.plan_id}</span>
                        </div>
                        <div class="task-action">${isRunning ? 'Generating Plan...' : 'Analyzing request...'}</div>
                        <div class="task-meta">
                            <i data-lucide="loader-2" size="12"></i>
                            ${plan.status}
                        </div>
                    `;

                let targetContainer;
                if (isRunning) {
                    targetContainer = elements.cols.running.querySelector('.col-cards');
                    counts.running++;
                } else {
                    targetContainer = elements.cols.pending.querySelector('.col-cards');
                    counts.pending++;
                }

                if (targetContainer) targetContainer.appendChild(card);
                lucide.createIcons();
            }
        }

        plan.steps.forEach(step => {
            // Skip planner-generated placeholder steps that haven't been executed
            // Show all steps including pending
            if (step.status === 'pending' && !step.result) {
                return;
            }

            // Hide rejected steps from Kanban
            if (step.status === 'rejected') {
                return;
            }

            const card = document.createElement('div');
            // ... (rest of logic)
            card.className = `task-card status-${step.status}`;
            card.dataset.stepId = step.step_id;
            card.onclick = () => openStepModal(step, plan);

            let statusIcon = 'clock';
            if (step.status === 'running') statusIcon = 'loader-2';
            if (step.status === 'completed') statusIcon = 'check-circle';
            if (step.status === 'cancelled') statusIcon = 'x-circle';
            if (step.status === 'waiting_input') statusIcon = 'alert-circle';

            let usageHtml = '';
            if (step.usage && step.usage.total_tokens > 0) {
                usageHtml = `<span style="display:flex;align-items:center;gap:3px;margin-left:auto;"${step.usage.total_tokens}</span>`;
            }

            card.innerHTML = `
                    <div class="task-header">
                        <span class="task-agent">${step.agent_id}</span>
                        <span class="task-id">#${step.step_id}</span>
                    </div>
                    <div class="task-action">${step.action}</div>
                    <div class="task-meta">
                         <i data-lucide="${statusIcon}" size="12"></i>
                         <span>${step.status}</span>
                         ${usageHtml}
                    </div>
                `;

            let targetCol;
            if (step.status === 'waiting_input') {
                targetCol = elements.cols.interaction.querySelector('.col-cards');
                // We don't track a separate count for interaction in the 'counts' object in the original code, 
                // but we should probably add it or reuse 'running'.
                // For now, let's assume we want to track it.
                // But wait, the original code had counts defined. I should update counts too.
            } else if (step.status === 'running') {
                targetCol = elements.cols.running.querySelector('.col-cards');
                counts.running++;
            } else if (['completed', 'failed', 'stopped', 'error', 'cancelled'].includes(step.status)) {
                targetCol = elements.cols.completed.querySelector('.col-cards');
                counts.completed++;
            } else {
                targetCol = elements.cols.pending.querySelector('.col-cards');
                counts.pending++;
            }

            if (targetCol) targetCol.appendChild(card);
        });

        elements.cols.pending.querySelector('.task-count').textContent = counts.pending;
        elements.cols.interaction.querySelector('.task-count').textContent = plan.steps.filter(s => s.status === 'waiting_input').length;
        elements.cols.running.querySelector('.task-count').textContent = counts.running;
        elements.cols.completed.querySelector('.task-count').textContent = counts.completed;

        lucide.createIcons();

        // Scroll logic
        // 1. Scroll on new plan (placeholder)
        // 2. Scroll on active plan progress
        // 3. STOP scroll if plan is completed/stopped/failed
        // Auto-scroll logic: Only scroll if state changed
        // Prioritize: Waiting Input > Running > Last Non-Pending > First Step
        let lastStep = plan.steps.find(s => s.status === 'waiting_input');
        if (!lastStep) lastStep = plan.steps.find(s => s.status === 'running');
        if (!lastStep) {
            const executed = plan.steps.filter(s => s.status !== 'pending');
            if (executed.length > 0) lastStep = executed[executed.length - 1];
        }
        if (!lastStep && plan.steps.length > 0) lastStep = plan.steps[0];

        const currentSignature = `${plan.plan_id}-${plan.status}-${lastStep ? lastStep.step_id : '0'}-${lastStep ? lastStep.status : 'none'}`;

        let scrollTarget = null;

        if (currentSignature !== lastAutoScrollSignature) {
            if (['completed', 'failed'].includes(plan.status)) {
                // Do not auto-scroll
            } else if (plan.steps.length === 0) {
                // New Plan Placeholder Case
                if (plan.status === 'running') {
                    scrollTarget = elements.cols.running.querySelector('.col-cards');
                } else {
                    scrollTarget = elements.cols.pending.querySelector('.col-cards');
                }
            } else {
                // Existing Steps Case
                // Use the same logic as before to find target column
                if (lastStep.status === 'waiting_input') {
                    scrollTarget = elements.cols.interaction.querySelector('.col-cards');
                } else if (lastStep.status === 'running') {
                    scrollTarget = elements.cols.running.querySelector('.col-cards');
                } else if (['completed', 'failed', 'stopped', 'error', 'cancelled', 'skipped'].includes(lastStep.status)) {
                    scrollTarget = elements.cols.completed.querySelector('.col-cards');
                } else {
                    scrollTarget = elements.cols.pending.querySelector('.col-cards');
                }
            }

            if (scrollTarget) {
                lastAutoScrollSignature = currentSignature;
                requestAnimationFrame(() => {
                    // Vertical scroll of the card list
                    if (scrollTarget.scrollHeight > scrollTarget.clientHeight) {
                        scrollTarget.scrollTop = scrollTarget.scrollHeight;
                    }

                    // Horizontal scroll of the entire Kanban board
                    const col = scrollTarget.parentElement;
                    if (col) {
                        col.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                    }
                });
            }
        }
    }

    function renderStepList(plan) {
        elements.stepLogs.innerHTML = '';
        // Show completed, running, waiting AND rejected steps
        // Show completed, running, waiting, rejected AND cancelled steps
        plan.steps.filter(s => ['completed', 'running', 'waiting_input', 'rejected', 'cancelled'].includes(s.status)).forEach(s => {
            const item = document.createElement('div');
            item.className = 'step-log-item';
            if (s.status === 'waiting_input') item.style.borderColor = 'var(--accent)';
            if (s.status === 'rejected' || s.status === 'cancelled') {
                item.style.borderColor = '#ef4444';
                item.style.opacity = '0.7';
            }

            item.innerHTML = `
                    <div class="step-log-header">
                        <span class="tag-agent">[${s.agent_id}]</span>
                        <span class="tag-action">${s.action}</span>
                        ${s.usage && s.usage.total_tokens > 0 ? `<span style="margin-left: auto; margin-right: 1rem; color: var(--text-dim); font-size: 0.75rem; display: flex; align-items: center; gap: 4px;"><i data-lucide="cpu" size="6"></i> ${s.usage.total_tokens.toLocaleString()}</span>` : ''}
                        <span style="${(!s.usage || s.usage.total_tokens <= 0) ? 'margin-left:auto;' : ''} color: ${s.status === 'waiting_input' ? 'var(--accent)' : ((s.status === 'rejected' || s.status === 'cancelled') ? '#ef4444' : 'inherit')}">${s.status}</span>
                    </div>
                    ${s.result ? `<div class="step-log-content">${s.result}</div>` : ''}
                `;
            elements.stepLogs.appendChild(item);
        });
        if (elements.stepLogs.innerHTML === '') {
            elements.stepLogs.innerHTML = '<div class="message">Wacht op agents om te beginnen...</div>';
        }
    }

    let currentStep = null;
    let currentPlan = null;

    function syntaxHighlight(json) {
        if (typeof json !== 'string') {
            json = JSON.stringify(json, undefined, 2);
        }
        json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
            let style = 'color: #fca5a5;'; // number
            if (/^"/.test(match)) {
                if (/:$/.test(match)) {
                    style = 'color: #93c5fd;'; // key
                } else {
                    style = 'color: #86efac;'; // string
                }
            } else if (/true|false/.test(match)) {
                style = 'color: #fcd34d;'; // boolean
            } else if (/null/.test(match)) {
                style = 'color: #cbd5e1;'; // null
            }
            return '<span style="' + style + '">' + match + '</span>';
        });
    }

    function openStepModal(step, plan) {
        currentStep = step;
        currentPlan = plan;

        const modal = document.getElementById('step-modal');
        const title = document.getElementById('modal-title');
        const subtitle = document.getElementById('modal-subtitle');
        const body = document.getElementById('modal-body');
        const footer = document.getElementById('modal-footer');
        let footerHTML = '';

        title.textContent = step.action;
        // Context/Debug info
        subtitle.textContent = `${step.agent_id}  Step #${step.step_id}  Plan: ${plan.plan_id} (${step.status})`;

        let bodyHTML = `
                <div class="info-row">
                    <span class="info-label">Status:</span>
                    <span class="info-value">${step.status}</span>
                </div>
            `;

        // Show Plan Intent context
        if (plan.intent && (plan.intent.prompt || plan.intent.initial_prompt)) {
            bodyHTML += `
                    <div style="margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--glass-border);">
                        <span class="info-label">Context (Intent):</span>
                        <div style="font-size: 0.85rem; color: #e2e8f0; margin-top: 0.25rem; font-style: italic;">"${plan.intent.prompt || plan.intent.initial_prompt}"</div>
                        ${plan.intent.action ? `<div style="font-size: 0.75rem; color: var(--text-dim); margin-top: 0.1rem;">Type: ${plan.intent.action}</div>` : ''}
                    </div>
                `;
        }

        if (step.params && Object.keys(step.params).length > 0) {
            bodyHTML += `
                    <div style="margin-bottom: 1rem;">
                        <span class="info-label">Parameters:</span>
                        <div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 0.5rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; margin-top: 0.25rem; white-space: pre-wrap; overflow-x: auto;">${syntaxHighlight(step.params)}</div>
                    </div>
                 `;
        }

        if (step.result) {
            // Try to format result if it looks like JSON
            let resultDisplay = step.result;
            try {
                if (resultDisplay.trim().startsWith('{') || resultDisplay.trim().startsWith('[')) {
                    const parsed = JSON.parse(resultDisplay);
                    resultDisplay = `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 0.5rem; font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; margin-top: 0.25rem; white-space: pre-wrap; overflow-x: auto;">${syntaxHighlight(parsed)}</div>`;
                }
            } catch (e) { }

            // If not formatted as JSON code block, wrap in result div
            if (resultDisplay === step.result) {
                resultDisplay = `<div class="modal-result" style="white-space: pre-wrap;">${step.result}</div>`;
            }

            bodyHTML += `
                    <div>
                        <div class="info-label" style="margin-bottom: 0.5rem;">Result / Output:</div>
                        ${resultDisplay}
                    </div>
                `;
        }

        // Footer Actions Logic
        footerHTML = ''; // Reset

        // 1. Interactive Input Required
        if (step.status === 'waiting_input' || (plan.status === 'waiting_input' && step.status === 'running')) {
            footerHTML = `
                    <div class="feedback-section">
                        <label class="info-label">Your Response:</label>
                        <textarea id="feedback-input" class="feedback-input" placeholder="Type je verbetering..."></textarea>
                        <div class="modal-actions">
                            <button class="modal-btn primary" onclick="submitModalAction('/accept')">
                                <i data-lucide="check" size="16"></i> Ok
                            </button>
                            <button class="modal-btn" onclick="submitModalFeedback()">
                                <i data-lucide="message-square" size="16"></i> Feedback
                            </button>
                            <button class="modal-btn danger" onclick="submitModalAction('/stop')">
                                <i data-lucide="x" size="16"></i> Stop
                            </button>
                        </div>
                    </div>
                `;
        }
        // 2. Resume for Stopped/Failed Plans (Global Resume) - Prioritize this if plan is halted
        else if (step.status === 'pending' || plan.status === 'stopped' || plan.status === 'failed' || plan.status === 'error') {
            // For stopped/failed plans, allow Resume OR Cancel
            footerHTML = `
                    <div class="modal-actions">
                        <button class="modal-btn primary" onclick="submitModalAction('/resume')">
                            <i data-lucide="play" size="16"></i> Resume
                        </button>
                        <button class="modal-btn danger" onclick="submitModalAction('/stop')">
                            <i data-lucide="x" size="16"></i> Cancel Plan
                        </button>
                    </div>
                `;
        } // 3. Resume for Stopped/Failed Plans (Global Resume) - Prioritize this if plan is halted
        else if (step.status === 'cancelled' || plan.status === 'stopped' || plan.status === 'failed' || plan.status === 'error') {
            // For stopped/failed plans, allow Resume OR Cancel
            footerHTML = `
                    <div class="modal-actions">
                        <button class="modal-btn primary" onclick="submitModalAction('/resume')">
                            <i data-lucide="play" size="16"></i> Resume
                        </button>
                    </div>
                `;
        }


        body.innerHTML = bodyHTML;
        footer.innerHTML = footerHTML;
        footer.style.display = footerHTML ? 'flex' : 'none';
        modal.classList.add('active');
        lucide.createIcons();
    }

    function closeStepModal() {
        document.getElementById('step-modal').classList.remove('active');
        currentStep = null;
        currentPlan = null;
    }

    // Close on ESC
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeStepModal();
        }
    });

    async function submitModalAction(action) {
        if (!currentPlan) return;

        if (action === '/stop') {
            try {
                const resp = await fetch(`/v1/plans/${currentPlan.plan_id}/stop`, { method: 'POST' });
                if (resp.ok) {
                    addChatMessage('user', ' Stop signaal verstuurd.');
                    await updatePlan();
                    await updateLogs();
                } else {
                    addChatMessage('ai', ` Fout bij het stoppen van het plan: ${await resp.text()}`);
                }
            } catch (e) {
                addChatMessage('ai', ` Fout bij het stoppen van het plan: ${e.message}`);
            }
        } else if (action === '/resume') {
            try {
                const resp = await fetch(`/v1/plans/${currentPlan.plan_id}/resume`, { method: 'POST' });
                if (resp.ok) {
                    addChatMessage('ai', ` Plan hervat: ${currentPlan.plan_id}`);
                    await updatePlan();
                    await updateLogs();
                } else {
                    addChatMessage('ai', ` Fout bij het hervatten van het plan: ${await resp.text()}`);
                }
            } catch (e) {
                addChatMessage('ai', ` Fout bij het hervatten van het plan: ${e.message}`);
            }
        } else {
            await sendTaskInput(currentPlan.plan_id, action);
        }
        closeStepModal();
    }

    async function submitModalFeedback() {
        const input = document.getElementById('feedback-input');
        const feedback = input?.value.trim();
        if (!feedback || !currentPlan) return;

        await sendTaskInput(currentPlan.plan_id, feedback);
        closeStepModal();
    }

    // Close modal on background click
    document.getElementById('step-modal').onclick = (e) => {
        if (e.target.id === 'step-modal') closeStepModal();
    };

    function createNewPlan() {
        if (state.pollingInterval) clearInterval(state.pollingInterval);
        state.pollingInterval = null;
        state.currentPlanId = null;
        state.shownStepIds = new Set();
        state.lastLogIndex = 0;

        elements.planSelector.value = "";
        elements.chat.innerHTML = '';
        elements.systemLogs.innerHTML = '';
        elements.stepLogs.innerHTML = '';

        // Clear Kanban board
        Object.values(elements.cols).forEach(col => {
            const cardsContainer = col.querySelector('.col-cards');
            if (cardsContainer) cardsContainer.innerHTML = '';
            col.querySelector('.task-count').textContent = '0';
        });
        // Reset Kanban background
        document.getElementById('kanban-container').className = '';

        addChatMessage('ai', 'Klaar voor een nieuw plan. Hoe kan ik je helpen?');
    }

    elements.send.onclick = sendMessage;
    elements.prompt.onkeydown = (e) => {
        if (e.key === 'Enter') sendMessage();
    };

    // Initialize Auth
    initAuth();

    // --- Task & Notification Logic ---
    async function checkTasks() {
        if (!state.token && !state.isDemo) return;
        try {
            const res = await fetch('/v1/tasks');
            if (res.status === 401 || !res.ok) return;
            const tasks = await res.json();

            const badge = document.getElementById('notification-badge');
            const listItems = document.getElementById('notification-items');

            if (tasks && tasks.length > 0) {
                badge.textContent = tasks.length;
                badge.style.display = 'flex';

                listItems.innerHTML = '';
                tasks.forEach(task => {
                    const item = document.createElement('div');
                    item.className = 'notification-item';
                    item.onclick = (e) => {
                        e.stopPropagation();
                        openTask(task.plan_id, task.step_id);
                    };

                    let desc = task.description || 'Waiting for input...';
                    if (desc.length > 80) desc = desc.substring(0, 80) + '...';

                    item.innerHTML = `
                        <div class="notification-plan">
                            <span>${task.plan_name ? task.plan_name.substring(0, 25) + (task.plan_name.length > 25 ? '...' : '') : 'Unknown Plan'}</span>
                            <span style="font-size:0.7rem; opacity:0.7">#${task.step_id}</span>
                        </div>
                        <div class="notification-desc">${desc}</div>
                        <div class="notification-meta">
                            <span class="tag-group">${task.assigned_group || 'Public'}</span>
                            <span>${task.agent_id}</span>
                        </div>
                    `;
                    listItems.appendChild(item);
                });
            } else {
                badge.style.display = 'none';
                listItems.innerHTML = '<div style="padding: 2rem; color: var(--text-dim); font-size: 0.8rem; text-align: center;">No pending tasks</div>';
            }
        } catch (e) {
            console.error("Failed to check tasks", e);
        }
    }

    window.openTask = async (planId, stepId) => {
        document.getElementById('notification-list').style.display = 'none';

        if (state.currentPlanId !== planId) {
            elements.planSelector.value = planId;
            // Manually trigger change
            elements.planSelector.onchange();
            // Wait for render
            setTimeout(() => waitForElementAndScroll(stepId), 1000);
        } else {
            waitForElementAndScroll(stepId);
        }
    };

    function waitForElementAndScroll(stepId) {
        let attempts = 0;
        const check = setInterval(() => {
            attempts++;
            const card = document.querySelector(`.task-card[data-step-id="${stepId}"]`);
            if (card) {
                clearInterval(check);
                card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                card.style.borderColor = 'var(--running)';
                card.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    card.style.borderColor = '';
                    card.style.transform = '';
                }, 2000);
            }
            if (attempts > 20) clearInterval(check);
        }, 100);
    }

    // Init Logic
    function initNotifications() {
        const wrap = document.getElementById('notifications-wrapper');
        const list = document.getElementById('notification-list');

        wrap.onclick = (e) => {
            if (list.style.display === 'none' || !list.style.display) {
                list.style.display = 'block';
                checkTasks();
            } else {
                list.style.display = 'none';
            }
            e.stopPropagation();
        };

        document.addEventListener('click', (e) => {
            if (!wrap.contains(e.target)) {
                list.style.display = 'none';
            }
        });

        setInterval(checkTasks, 10000);
        setTimeout(checkTasks, 1000); // Initial check after auth likely done
    }

    // Call it
    initNotifications();

</script>
</body>

</html>